Hi,
Thank you for creating the course, I think it is well put together and contains the critical patterns to learn for coding interviews.
I have some comments that I would like to share, along with some errata, for you to consider updating in the next version:

---

In the Python solutions, there is a mixture of camelCase and snake_case. While I believe it may be allowed in the official documentation, Python convention is generally for snake_case with variable names.
Ex. Solution to Triplet Sum to Zero (medium) is an excellent example of typical Python Convention while Squaring a Sorted Array (easy) mixes the conventions between function and variable names.
The following modules have non-typical conventions which I would be happy to submit solutions for if interested:2. Pattern: Two PointersSquaring a Sorted Array (easy)4. Pattern Islands (or Matrix Traversal) (_NEW_)
All exercises6. Pattern: Merge IntervalsMerge Intervals (medium)Problem Challenge 1Problem Challenge 37. Pattern: Cyclic SortFind all Missing Numbers (easy)Find the Duplicate Number (easy) (solution2)Find all Duplicate Numbers (easy)Problem Challenge 39. Pattern: Tree Breadth First SearchBinary Tree Level Order Traversal (easy)Reverse Level Order Traversal (easy)
Zigzag Traversal (medium)Level Averages in a Binary Tree (easy)
Minimum Depth of a Binary Tree (easy)
Level Order Successor (medium)
Connect Level Order Siblings (medium)Problem Challenge 1
Problem Challenge 210. Pattern: Tree Depth First SearchAll paths for a Sum (medium)Sum of Path Numbers (medium)Path With Given Sequence (medium)Count Paths for a Sum (medium)Problem Challenge 1Problem Challenge 211. Pattern: Two HeapsFind the Median of a Number Stream (medium)Sliding Window Median (hard)Maximum Capital (hard)Problem Challenge 112. Pattern: SubsetsSubsets (easy)Subsets With Duplicates (easy)Permutations (medium)Balanced Parentheses (hard)Unique Generalized Abbreviations (hard)Problem Challenge 1Problem Challenge 2
Problem Challenge 3

Additionally, most of the above Python solutions do not have correct indentation. There are only 2 spaces when there should be 4 spaces for an indent. If you paste the solutions into an editor without an auto-formatter, you will need to fix all the indentation in order to run the solution.-------------------- 3. Pattern: Fast & Slow PointersStart of LinkedList Cycle (medium) - In this solution, the `from __future__ import print_function` line is not needed and may be confusing to some students. I assume this is an artifact of testing and most will not be running this code as its own module.

---

Problem Challenge 2 - The font of the hyperlink to Middle of the LinkedList is different from the rest of the site.

---

4. Pattern Islands (or Matrix Traversal) (_NEW_)Number of Islands (easy) - In the section for BFS there is a missing closing parenthesis for the big O notation.

---

Number of Islands (easy) - In the section for BFS with visited matrix, there is a type that states incorrectly that it is a DFS algorithm.

---

Problem Challenge 2 - In the Python solution on line 11, there is a semicolon ending the statement. Semicolons don't break the Python interpreter, they are only allowed if using more than one statement per line.                traversal = traverseIslandDFS(matrix, visited, i, j, "O"); # origin

---

5. Pattern: Sliding WindowSmallest Subarray with a Greater Sum (easy) - In the Python solution on line 9, the start value of 0 can be omitted from the range() function since it is the default and consistent with other solutions.    for window_end in range(0, len(arr)):

---

## Fruits into Baskets (medium) - This lesson is missing the green dividers present in other lessons.

## Longest Substring with Distinct Characters (hard) - In th problem statement, there is a whitespace in front of the "Example 1:" heading. Note: this is a minor formatting detail.

## Problem Challenge 4 - In the Python solution on line 18, the start value of 0 can be omitted from the range() function since it is the default and consistent with other solutions.

6. Pattern: Merge IntervalsMerge Intervals (medium) - In this solution, the `from __future__ import print_function` line is not needed and may be confusing to some students. I assume this is an artifact of testing and most will not be running this code as its own module.

---

## Intervals Intersection (medium) - In the Python solution on line 16, there is a typo where the word `the` is repeated twice in the comment: # store the the intersection part

## Problem Challenge 1 - importing with a wildcard (\*) from a library will cause a linting error since this could cause naming issues. I'd suggest importing the functions that are being used directly as from heapq import heappop, heappush

## Problem Challenge 2 - By convention, class names (job) should start with a capital letter.Same comment as above in regards to the wildcard import statement.

Problem Challenge 3 - Same comment as Problem Challenge 1 for the import `from __future`.Same comment as above in regards to the wildcard import statement.

---

7. Pattern: Cyclic SortProblem Challenge 3 - In this solution, there is an inconsistent declaration of i and n. It is done on one line in previous solutions. Also, the while loop can be instantiated on n since it has been declared as the length of the array:    n = len(nums)    i = 0    while i < len(nums):This would be more consistent with other solutions (see Problem Challenge 2) as:    i, n = 0, len(nums)    while i < n:

---

8. Pattern: In-place Reversal of a Linked ListReverse a LinkedList (easy) - In this solution, the `from __future__ import print_function` line is not needed and may be confusing to some students. I assume this is an artifact of testing and most will not be running this code as its own module.
   This module also utilizes significant use of the reserved keyword next. Perhaps a better variable name would be next_node.

---

## Reverse a Sub-list (medium) - Same comments as above.

## Reverse every K-element Sub-list (medium) - Same comments as above.

## Problem Challenge 1 - Same comments as above.

9. Pattern: Tree Breadth First SearchBinary Tree Level Order (easy) - The solution to this class has properties set implicitly rather than by the constructor. This causes linting issues as the type of left and right properties are seen as None. This can be solved by setting the default values as parameters in the constructor itself:class TreeNode:    def **init**(self, value, left=None, right=None):        self.value = value        self.left = left        self.right = right

---

## Reverse Level Order Traversal (easy) - Same comment as above.

Zigzag Traversal (medium) - Same comment as above.

---

## Level Averages in a Binary Tree (easy) - Same comment as above.

## Minimum Depth of a Binary Tree (easy) - Same comment as above.

## Level Order Successor (medium) - Same comment as above.

Connect Level Order Siblings (medium) - Same comment as above, but also with next as a default parameter.

---

## Problem Challenge 1 - Same comment as above for TreeNode. The same comment previously mentioned for omitting the import statement for print_function also applies.

Problem Challenge 2  - Same comments as above. Also on line 20, the default start parameter for the range function can be removed to be consistent with other solutions:for i in range(0, levelSize):

---

10. Pattern: Tree Depth First SearchBinary Tree Path Sum (easy) - In the Python solution, the sum used as a parameter is a reserved keyword and this would be better named as total or just s. It doesn't affect this program, but might be considered bad practice.

---

11. Pattern: Two Heaps
    Note: There are some more efficient ways to manage heaps in Python. See https://docs.python.org/3/library/heapq.html for details of using heappushpop and heapify.

Find the Median of a Number Stream (medium) - importing with a wildcard (\*) from a library will cause a linting error since this could cause naming issues. I'd suggest importing the functions that are being used directly as from heapq import heappop, heappush
See above note for using heappushpop.-----
Sliding Window Median (hard) - On line 11, the start value for the range function can be eliminated since it is 0 by default.
On line 10, the value x can be replaced with an anonymous variable such as \_ to be consistent with other solutions since it is not used for anything other than the iteration.The import statements in this solution are also awkward since the entire module is being imported with a wildcard and as a module. The use of private methods here is also a strange practice, while it works, linters will show the modules unavailable due to the private naming prefixed with an underscore (\_method). It may be better to use heapify which turns the list into a heap in-place, which would also be O(K) time for the remove method. The below suggestion seems to work:    def remove(self, heap, element):        ind = heap.index(element)        heap[ind] = heap[-1]        del heap[-1]
        heapify(heap)and the import statement can be simplified to:from heapq import heapify, heappop, heappush
See above note for using heappushpop.

---

Maximum Capital (hard) - Same comment regarding import statement for heappop, heappush.
Line 9, the start value can be removed to be consistent with other solutions.

---

Problem Challenge 1 - Same comment regarding import statement for heappop, heappush.

---

12. Pattern: SubsetsSubsets (easy) - This solution can be simplified by initializing the array with an empty array rather than initializing it empty and appending an empty array on the next line:    subsets = [[]]

---

## Subsets With Duplicates (easy) -  This solution can benefit from the same simplification mentioned above. It would also be more common to invoke the sort method on the array rather than the callable from list on line 3:    nums.sort()

## String Permutations by changing case (medium) - Similar comment as above for the initialization of the permutations list:    permutations = [str]

## Unique Generalized Abbreviations (hard) - In the Python solution on line 6, there is an extra whitespace before the count parameter. This won't break the program, but will cause warnings from the linter. def **init**(self, str, start, count):

## Problem Challenge 1 - In the Python solution on line 7, the 0 start parameter can be eliminated to be consistent with other solutions.

Problem Challenge 2 - As mentioned for previous solutions, the default parameters can be set for the TreeNode class:
class TreeNode:    def **init**(self, val, left=None, right=None):        self.val = val        self.left = left        self.right = rightThe solution can then be further simplified by passing the left and right properties when creating a new object, rather than setting them explicitly:        for left_tree in left_subtrees:            for right_tree in right_subtrees:                root = TreeNode(i, left_tree, right_tree)                result.append(root)

---

Problem Challenge 3 - Same comment as above for the TreeNode class.
